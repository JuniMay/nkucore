/* Simple implementation to interpret the device tree generated by OpenSBI.
 *
 * References:
 *   Devicetree spec: https://www.devicetree.org/specifications/
 *   FDT format:
 * https://devicetree-specification.readthedocs.io/en/stable/flattened-format.html
 *
 * All the property values are output in hexadecimals rather than in their
 * original formats.
 *
 */

#ifndef __LIBS_FDT_H__
#define __LIBS_FDT_H__

#include <defs.h>
#include <stdio.h>

/// Stored in big-endian format.
///
/// +--------------------------+
/// |    struct fid_header     |
/// +--------------------------+
/// | memory reservation block | <-- Memory which are reserved. Offset shall be
/// aligned to 8 bytes.
/// +--------------------------+
/// |      structure block     | <-- Structure and contents of the devicetree.
/// +--------------------------+
/// |       strings block      |
/// +--------------------------+
///
/// There might also be free spaces for some alignment constraints.
typedef struct {
    /// 0xd00dfeed
    uint32_t magic;
    /// Total size in bytes, including header.
    uint32_t totalsize;
    /// Offset of the structure block in bytes from the beginning of the header.
    uint32_t off_dt_struct;
    /// Offset of the strings block in bytes from the beginning of the header.
    uint32_t off_dt_strings;
    /// Offset of the memory reservation block in bytes from the beginning of
    /// the header.
    uint32_t off_mem_rsvmap;
    /// Version of the devicetree data structure.
    uint32_t version;
    /// The lowest version of the devicetree data structure with which the
    /// version used is backwards compatible.
    uint32_t last_comp_version;
    /// Boot CPU physical ID.
    uint32_t boot_cpuid_phys;
    /// Length in bytes of the strings block section.
    uint32_t size_dt_strings;
    /// Length in bytes of the structure block section.
    uint32_t size_dt_struct;
} fdt_header_t;

/// Memory reservation block pair.
///
/// The memory reservation block ends if the address and size are both zero.
typedef struct {
    /// Physical address
    uint64_t address;
    /// Size of the memory region
    uint64_t size;
} fdt_reserve_entry_t;

/// A beginning of a node's representation.
#define FDT_BEGIN_NODE 0x01000000
/// An end of a node's representation.
#define FDT_END_NODE 0x02000000
/// Mark the beginning of the representation of one property in the devicetree.
#define FDT_PROP 0x03000000
/// Property data following the property marker.
typedef struct {
    /// Length of the property value in bytes.
    uint32_t len;
    /// Offset into the strings block for the property name.
    uint32_t nameoff;
} fdt_prop_data_t;
/// No extra data.
#define FDT_NOP 0x04000000
/// The end of the structure block.
#define FDT_END 0x09000000

void walk_print_device_tree(fdt_header_t* fdt_header);

uint32_t le2be(uint32_t val) {
    return ((val & 0xff000000) >> 24) | ((val & 0x00ff0000) >> 8) |
           ((val & 0x0000ff00) << 8) | ((val & 0x000000ff) << 24);
}

void walk_print_device_tree(fdt_header_t* fdt_header) {
    // Big-endian magic number check. 0xd00dfeed
    assert(fdt_header->magic == 0xedfe0dd0);

    uint64_t fdt_end_addr = (uint64_t)fdt_header + le2be(fdt_header->totalsize);
    uint64_t structure_block_addr =
        (uint64_t)fdt_header + le2be(fdt_header->off_dt_struct);
    uint64_t strings_block_addr =
        (uint64_t)fdt_header + le2be(fdt_header->off_dt_strings);

    size_t node_depth = 0;

    uint32_t* p = (uint32_t*)structure_block_addr;

    for (;;) {
        uint32_t marker = *p;

        switch (marker) {
            case FDT_NOP: {
                p++;
                break;
            }
            case FDT_BEGIN_NODE: {
                cputs("\n");
                p++;
                node_depth++;
                for (size_t i = 0; i < node_depth; i++) {
                    cprintf("  ");
                }

                cprintf("%s\n", (char*)p);
                p += strlen((char*)p) / sizeof(uint32_t) + 1;
                break;
            }
            case FDT_END_NODE: {
                p++;
                node_depth--;
                break;
            }
            case FDT_PROP: {
                p++;
                fdt_prop_data_t* prop_data = (fdt_prop_data_t*)p;
                p += sizeof(fdt_prop_data_t) / sizeof(uint32_t);

                for (size_t i = 0; i <= node_depth; i++) {
                    cprintf("  ");
                }

                cprintf("%s: ", (char*)(strings_block_addr +
                                        le2be(prop_data->nameoff)));

                uint8_t* prop_value = (uint8_t*)p;

                for (size_t i = 0; i < le2be(prop_data->len); i++) {
                    uint8_t c = prop_value[i];
                    cprintf("%02x ", c);
                }

                // Find the next 4-byte aligned address.
                p += (le2be(prop_data->len) + 3) / sizeof(uint32_t);

                cprintf("\n");

                break;
            }
            case FDT_END: {
                return;
            }
            default: {
                cprintf("unknown marker: 0x%08x\n", marker);
                return;
            }
        }
        if (node_depth == 0) {
            return;
        }

        if ((uint64_t)p >= fdt_end_addr) {
            return;
        }
    }
}

#endif